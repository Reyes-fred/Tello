/**
 * Generated by Eclipse Mita.
 * @date 2018-11-09 12:41:59
 */


#include <BCDS_Basics.h>
#include <BCDS_Bma280Utils.h>
#include <bma2x2.h>
#include <XdkSensorHandle.h>
#include <BCDS_CmdProcessor.h>
#include <BCDS_Retcode.h>
#include "MitaEvents.h"
#include "MitaExceptions.h"



/* BMA280 ISR Callback */
static void BMA280_IsrCallback(uint32_t channel, uint32_t edge);

/* BMA280 Event Resolver */
static Retcode_T BMA280_Event(void * param1, uint32_t param2);

static void BMA280_IsrCallback(uint32_t channel, uint32_t edge)
{
    BCDS_UNUSED(channel);
    BCDS_UNUSED(edge);

    /* Enqueue Event Resolver */
    CmdProcessor_EnqueueFromIsr(&Mita_EventQueue, BMA280_Event, NULL, 0);
}

static Retcode_T BMA280_Event(void* param1, uint32_t param2)
{
    (void) param1;
    (void) param2;
    
    /* Read from interrupt status information */
    uint8_t interruptSource[4];
    (void) bma2x2_get_intr_stat(interruptSource);
    
    /* Trigger the corresponding event depending on the ISR mask */
    if(interruptSource[BMA2x2_STAT1] & BMA2x2_SINGLE_TAP_INTR_STAT_MSK)
    {
        CmdProcessor_Enqueue(&Mita_EventQueue, HandleEveryAccelerometerSingle_tap1, NULL, 0);
    }
    if(interruptSource[BMA2x2_STAT1] & BMA2x2_DOUBLE_TAP_INTR_STAT_MSK)
    {
        CmdProcessor_Enqueue(&Mita_EventQueue, HandleEveryAccelerometerDouble_tap1, NULL, 0);
    }

    return RETCODE_OK;
}


Retcode_T SensorAccelerometer_Setup(void)
{
	Retcode_T retcode = RETCODE_OK;
	
	/* Extract BMA280 Handle from Advanced API */
	Bma280Utils_InfoPtr_T bma280UtilityCfg = xdkAccelerometers_BMA280_Handle->SensorPtr;
	
	/* Register Callback */
	bma280UtilityCfg->ISRCallback = BMA280_IsrCallback;
	
	retcode = Bma280Utils_initialize(bma280UtilityCfg);
	if(retcode != RETCODE_OK)
	{
	    return retcode;
	}
	
	/* Do soft reset and wait 2-3 ms */
	// bma2x2_soft_rst();
	/* Overwrite settings */
	
	/* Block One: Basic Settings */
	/* Required: Set power mode to normal for configuration */
	bma2x2_set_power_mode(BMA2x2_MODE_NORMAL);
	
	/* Set Bandwidth */
	bma2x2_set_bw(BMA2x2_BW_500HZ);
	
	/* Setting to filtered low-bandwidth */
	bma2x2_set_high_bw(1);
	
	/* Set Range */
	bma2x2_set_range(BMA2x2_RANGE_2G);
	
	/* Set Sleep Duration */
	//bma2x2_set_sleep_durn(BMA2x2_SLEEP_DURN_1S);
	//bma2x2_set_sleep_timer_mode(0);
	/* Set Interrupt latch and level */
	
	/* Output stages */
	bma2x2_set_latch_intr(BMA2x2_LATCH_DURN_250MS);
	bma2x2_set_intr_level(BMA2x2_INTR1_LEVEL, ACTIVE_LOW);
	bma2x2_set_intr_level(BMA2x2_INTR2_LEVEL, ACTIVE_LOW);
	bma2x2_set_intr_output_type(BMA2x2_INTR1_OUTPUT, PUSS_PULL);
	bma2x2_set_intr_output_type(BMA2x2_INTR2_OUTPUT, PUSS_PULL);
	
	/* Set power mode to target value */
	bma2x2_set_power_mode(BMA2x2_MODE_NORMAL);
	
	/* Group 1: INTR1 Settings */
	bma2x2_set_intr_low_g(BMA2x2_INTR1_LOW_G, INTR_ENABLE);
	bma2x2_set_intr_high_g(BMA2x2_INTR1_HIGH_G, INTR_ENABLE);
	bma2x2_set_intr_slope(BMA2x2_INTR1_SLOPE, INTR_ENABLE);
	bma2x2_set_intr_slow_no_motion(BMA2x2_INTR1_SLOW_NO_MOTION, INTR_ENABLE);
	bma2x2_set_intr_double_tap(BMA2x2_INTR1_DOUBLE_TAP, INTR_ENABLE);
	bma2x2_set_intr_single_tap(BMA2x2_INTR1_SINGLE_TAP, INTR_ENABLE);
	bma2x2_set_intr_orient(BMA2x2_INTR1_ORIENT, INTR_ENABLE);
	bma2x2_set_intr_flat(BMA2x2_INTR1_FLAT, INTR_ENABLE);
	bma2x2_set_new_data(BMA2x2_INTR1_NEWDATA, INTR_ENABLE);
	bma2x2_set_intr1_fifo_wm(INTR_ENABLE);
	bma2x2_set_intr1_fifo_full(INTR_ENABLE);
	
	/* Group 2: INTR2 Settings */
	bma2x2_set_intr_low_g(BMA2x2_INTR2_LOW_G, INTR_DISABLE);
	bma2x2_set_intr_high_g(BMA2x2_INTR2_HIGH_G, INTR_DISABLE);
	bma2x2_set_intr_slope(BMA2x2_INTR2_SLOPE, INTR_DISABLE);
	bma2x2_set_intr_slow_no_motion(BMA2x2_INTR2_SLOW_NO_MOTION, INTR_DISABLE);
	bma2x2_set_intr_double_tap(BMA2x2_INTR2_DOUBLE_TAP, INTR_DISABLE);
	bma2x2_set_intr_single_tap(BMA2x2_INTR2_SINGLE_TAP, INTR_DISABLE);
	bma2x2_set_intr_orient(BMA2x2_INTR2_ORIENT, INTR_DISABLE);
	bma2x2_set_intr_flat(BMA2x2_INTR2_FLAT, INTR_DISABLE);
	bma2x2_set_new_data(BMA2x2_INTR2_NEWDATA, INTR_DISABLE);
	bma2x2_set_intr2_fifo_wm(INTR_DISABLE);
	bma2x2_set_intr2_fifo_full(INTR_DISABLE);
	
	
	
	
	
	/* single-tap double-tap */
	bma2x2_set_tap_durn(TAP_DURN_250_MS);
	bma2x2_set_tap_quiet(TAP_QUIET_30_MS);
	bma2x2_set_tap_thres((1.25 * 32 / 2.0)); //1250mg
	bma2x2_set_tap_shock(TAP_SHOCK_50_MS);
	bma2x2_set_source(BMA2x2_SOURCE_TAP, 0);
	//bma2x2_set_tap_sample( 0x02 );
	
	/* orientation */
	
	/* flat */
	
	/* New data */
	bma2x2_set_source(BMA2x2_SOURCE_DATA, 0);
	
	return NO_EXCEPTION;
}

Retcode_T SensorAccelerometer_Enable(void)
{
	/* Enable Active Sensor Events */
	/* Activating single_tap */
	bma2x2_set_intr_enable(BMA2x2_SINGLE_TAP_INTR, INTR_ENABLE);
	
	/* Activating double_tap */
	bma2x2_set_intr_enable(BMA2x2_DOUBLE_TAP_INTR, INTR_ENABLE);
	
	
	
	return NO_EXCEPTION;
}

Retcode_T SensorAccelerometer_ReadXYZ(struct bma2x2_accel_data* result)
{    
    // read sensor data
    BMA2x2_RETURN_FUNCTION_TYPE bmaReadRc = bma2x2_read_accel_xyz(result);
    if(bmaReadRc != 0)
    {
        return RETCODE(RETCODE_SEVERITY_ERROR, RETCODE_FAILURE);
    }

    // remap to XDK axis alignment
    AxisRemap_Data_T axisRemapping = { INT32_C(0), INT32_C(0), INT32_C(0) };
    axisRemapping.x = result->x;
    axisRemapping.y = result->y;
    axisRemapping.z = result->z;
    Retcode_T remappingStatus = Bma280Utils_remapAxis((Bma280Utils_InfoPtr_T) xdkAccelerometers_BMA280_Handle->SensorPtr, &axisRemapping);
    
    // store in result
    if (RETCODE_OK == remappingStatus)
    {
        result->x = axisRemapping.x;
        result->y = axisRemapping.y;
        result->z = axisRemapping.z;
        return RETCODE_OK;
    } else {
        return remappingStatus;
    }
}

